use std::rc::Rc;

use clap::crate_version;

use crate::providers::{FUNCTION_PROVIDERS, Provider, ROOT_PROVIDERS, SERVICE_PROVIDERS};
use crate::transpiler::{Castable, CastError, ContentType};
use crate::transpiler::context::{Context, Http};

pub struct NetRoot;

impl Castable for NetRoot {
    fn cast(&mut self, ctx: Rc<Context>, name: &str) -> Result<Vec<String>, CastError> {
        let mut out_vec = Vec::new();
        if let Ok(hcl) = self.cast_hcl(ctx.clone(), name) {
            out_vec.push(hcl);
        }
        let uses_k8s = ctx
            .services
            .iter()
            .find(|s| s.provider.name.contains("k8s"))
            .is_some();
        if uses_k8s {
            if let Ok(kube) = self.cast_kube(ctx.clone(), name) {
                out_vec.push(kube);
            }
        }
        Ok(out_vec)
    }

    fn content_type(&self) -> Vec<ContentType> {
        vec![ContentType::HCL("HCL"), ContentType::KubeYaml("kube-yaml")]
    }
}

impl NetRoot {
    fn cast_hcl(&mut self, ctx: Rc<Context>, name: &str) -> Result<String, CastError> {
        let mut content = format!("# Generated by assemblylift-cli {}\r\n", crate_version!());

        let mut provider = (*ROOT_PROVIDERS
            .get("root")
            .expect("could not find root provider"))
        .lock()
        .unwrap();
        let mut artifact = provider
            .cast(ctx.clone(), "root")
            .expect("unexpected error casting root");

        for (i, t) in provider.content_type().iter().enumerate() {
            if let ContentType::HCL(_) = t {
                content.push_str(&artifact[i].clone());
            }
        }

        let services = &ctx.clone().services;
        for service in services {
            let mut net_service = NetService;
            content.push_str(
                &net_service
                    .cast(ctx.clone(), &*service.name.clone())
                    .unwrap()[0]
                    .clone(),
            );
        }

        Ok(content)
    }

    fn cast_kube(&mut self, ctx: Rc<Context>, name: &str) -> Result<String, CastError> {
        let mut content = format!("# Generated by assemblylift-cli {}\r\n", crate_version!());

        // we have only one api provider under k8s and it creates a single resource at the 'root'
        // so we skip looking up the provider and/or making it a side-effect of the root provider
        // i.e. right now if you're using HTTP with the k8s provider you're using Gloo

        let project_name = ctx.project.name.clone();
        let has_api = ctx
            .functions
            .iter()
            .filter_map(|f| f.http.as_ref())
            .collect::<Vec<&Http>>()
            .len()
            > 0;

        if has_api {
            let mut api_provider = crate::providers::gloo::ApiProvider::new();
            api_provider.init(ctx.clone(), &*project_name).unwrap();
            content.push_str(
                &*api_provider.cast(ctx.clone(), &*project_name).unwrap()[0] // FIXME unchecked index
                    .clone(),
            );
        }

        Ok(content)
    }
}

pub struct NetService;

impl Castable for NetService {
    fn cast(&mut self, ctx: Rc<Context>, name: &str) -> Result<Vec<String>, CastError> {
        let service_name = name.clone();
        let mut content = format!("# Begin service `{}`\n", &service_name);

        match ctx.services.iter().find(|&s| s.name == name) {
            Some(service) => {
                let functions = &ctx.functions;

                let provider_name = service.provider.name.clone();
                let mut service_provider = SERVICE_PROVIDERS
                    .get(&provider_name)
                    .expect(&format!(
                        "could not find service provider named {}",
                        provider_name
                    ))
                    .lock()
                    .unwrap();

                service_provider
                    .set_options(service.provider.options.clone())
                    .expect("unable to set provider options");
                service_provider
                    .init(ctx.clone(), service_name.into())
                    .expect("unable to initialize service provider");

                let mut service_artifact = service_provider
                    .cast(ctx.clone(), &*service_name.clone())
                    .expect("unexpected error transforming service");
                content.push_str(&service_artifact[0].clone()); // FIXME unchecked index

                for function in functions.iter().filter(|&f| f.service_name == service_name) {
                    let mut net_function = NetFunction;
                    content.push_str(
                        &net_function.cast(ctx.clone(), &*function.name.clone()).unwrap()[0].clone(),
                    );
                }

                Ok(vec![content])
            }
            None => Err(CastError(format!(
                "unable to find service {} in context",
                &name
            ))),
        }
    }

    fn content_type(&self) -> Vec<ContentType> {
        vec![ContentType::HCL("HCL")]
    }
}

pub struct NetFunction;

impl Castable for NetFunction {
    fn cast(&mut self, ctx: Rc<Context>, name: &str) -> Result<Vec<String>, CastError> {
        match ctx.functions.iter().find(|&f| f.name == name) {
            Some(function) => {
                let provider_name = function.provider.name.clone();
                let mut function_provider = FUNCTION_PROVIDERS
                    .get(&provider_name)
                    .expect(&format!(
                        "could not find function provider named {}",
                        provider_name
                    ))
                    .lock()
                    .unwrap();

                function_provider
                    .set_options(function.provider.options.clone())
                    .expect("unable to set function provider options");
                function_provider
                    .init(ctx.clone(), &*function.name.clone())
                    .expect("unable to initialize function provider");

                let mut function_artifact = function_provider
                    .cast(ctx.clone(), &*function.name.clone())
                    .expect("unexpected error transforming function");
                let content = function_artifact[0].clone(); // FIXME unchecked index

                Ok(vec![content])
            }
            None => Err(CastError(format!(
                "unable to find function {} in context",
                &name
            ))),
        }
    }

    fn content_type(&self) -> Vec<ContentType> {
        vec![ContentType::HCL("HCL")]
    }
}
