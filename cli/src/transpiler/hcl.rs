pub mod root {
    use std::rc::Rc;

    use clap::crate_version;

    use crate::providers::*;
    use crate::transpiler::{asml, Castable, CastError, ContentType, hcl};

    pub type ArtifactList = Vec<Box<hcl::service::Module>>;

    pub struct Module {
        hcl: Rc<Option<String>>,
        pub services: Option<ArtifactList>,
    }

    impl Module {
        pub fn new() -> Self {
            Self { hcl: Rc::new(None), services: None }
        }
    }

    impl Castable for Module {
        fn cast(&mut self, ctx: Rc<asml::Context>, name: &str) -> Result<Vec<String>, CastError> {
            let mut content = format!("# Generated by assemblylift-cli {}\r\n", crate_version!());

            let mut provider = (*ROOT_PROVIDERS.get("root").expect("could not find root provider")).lock().unwrap();
            let mut artifact = provider.cast(ctx.clone(), "root")
                .expect("unexpected error transforming root manifest");
            let artifact_content = artifact[0].clone(); // FIXME unchecked index
            content.push_str(&artifact_content);

            let services = &ctx.clone().services;
            let mut service_modules: ArtifactList = ArtifactList::new();
            for service in services {
                let mut module = hcl::service::Module::new();
                content.push_str(&module.cast(ctx.clone(), &*service.name.clone()).unwrap()[0].clone());
                service_modules.push(Box::new(module));
            }

            self.services = Some(service_modules);
            self.hcl = Rc::new(Some(content.clone()));
            Ok(vec![content])
        }

        fn content_type(&self) -> Vec<ContentType> {
            vec![ContentType::HCL("HCL")]
        }
    }
}

pub mod service {
    use std::rc::Rc;

    use crate::providers::*;
    use crate::transpiler::{asml, Castable, CastError, ContentType, hcl, StringMap, toml};

    pub type ArtifactList = Vec<Box<hcl::function::Module>>;

    pub struct Module {
        hcl: Rc<Option<String>>,
        pub functions: Option<ArtifactList>,
        pub iomods: Option<StringMap<toml::service::Dependency>>,
    }

    impl Module {
        pub fn new() -> Self {
            Module { hcl: Rc::new(None), functions: None, iomods: None }
        }
    }

    impl Castable for Module {
        fn cast(&mut self, ctx: Rc<asml::Context>, name: &str) -> Result<Vec<String>, CastError> {
            let service_name = name.clone();
            let mut content = format!("# Begin service `{}`\n", &service_name);

            match ctx.services.iter().find(|&s| s.name == name) {
                Some(service) => {
                    let functions = &ctx.functions;

                    let provider_name = service.provider.name.clone();
                    let mut service_provider = SERVICE_PROVIDERS.get(&provider_name)
                        .expect(&format!("could not find service provider named {}", provider_name))
                        .lock()
                        .unwrap();

                    service_provider.set_options(service.provider.options.clone())
                        .expect("unable to set provider options");
                    service_provider.init(ctx.clone(), service_name.into())
                        .expect("unable to initialize service provider");

                    let mut service_artifact = service_provider.cast(ctx.clone(), &*service_name.clone())
                        .expect("unexpected error transforming service");
                    content.push_str(&service_artifact[0].clone()); // FIXME unchecked index

                    let mut function_modules: ArtifactList = ArtifactList::new();
                    for function in functions.iter().filter(|&f| f.service_name == service_name) {
                        let mut module = hcl::function::Module::new();
                        content.push_str(&module.cast(ctx.clone(), &*function.name.clone()).unwrap()[0].clone());
                        function_modules.push(Box::new(module));
                    }

                    self.hcl = Rc::new(Some(content.clone()));
                    self.functions = Some(function_modules);
                    Ok(vec![content])
                }
                None => Err(CastError(format!("unable to find service {} in context", &name))),
            }
        }

        fn content_type(&self) -> Vec<ContentType> {
            vec![ContentType::HCL("HCL")]
        }
    }
}

pub mod function {
    use std::rc::Rc;

    use crate::providers::*;
    use crate::transpiler::{asml, Castable, CastError, ContentType};

    pub struct Module {
        hcl: Rc<Option<String>>,
    }

    impl Module {
        pub fn new() -> Self {
            Self { hcl: Rc::new(None) }
        }
    }

    impl Castable for Module {
        fn cast(&mut self, ctx: Rc<asml::Context>, name: &str) -> Result<Vec<String>, CastError> {
            match ctx.functions.iter().find(|&f| f.name == name) {
                Some(function) => {
                    let provider_name = function.provider.name.clone();
                    let mut function_provider = FUNCTION_PROVIDERS.get(&provider_name)
                        .expect(&format!("could not find function provider named {}", provider_name))
                        .lock()
                        .unwrap();

                    function_provider.set_options(function.provider.options.clone())
                        .expect("unable to set function provider options");
                    function_provider.init(ctx.clone(), function.name.clone())
                        .expect("unable to initialize function provider");

                    let mut function_artifact = function_provider.cast(ctx.clone(), &*function.name.clone())
                        .expect("unexpected error transforming function");
                    let content = function_artifact[0].clone(); // FIXME unchecked index
                    self.hcl = Rc::new(Some(content.clone()));
                    Ok(vec![content])
                }
                None => Err(CastError(format!("unable to find function {} in context", &name))),
            }
        }

        fn content_type(&self) -> Vec<ContentType> {
            vec![ContentType::HCL("HCL")]
        }
    }
}
