pub mod root {
    use clap::crate_version;

    use crate::projectfs::Project;
    use crate::providers::*;
    use crate::materials::{toml, hcl, Artifact, ArtifactError, ContentType};

    pub type ArtifactList = Vec<Box<hcl::service::Module>>;

    pub struct Module {
        hcl: Option<String>,
        project: Project,
        pub services: Option<ArtifactList>,
    }

    impl Module {
        pub fn new(project: Project) -> Self {
            Self { hcl: None, services: None, project }
        }
    }

    impl Artifact for Module {
        fn content_type(&self) -> ContentType {
            ContentType::HCL("HCL")
        }

        fn content(&self) -> Option<String> {
            self.hcl
        }

        fn cast(&mut self) -> Result<String, ArtifactError> {
            let asml_manifest = toml::asml::Manifest::read(&self.project.dir()).unwrap();
            let mut content = format!("# Generated by assemblylift-cli {}\r\n", crate_version!());

            let provider = ROOT_PROVIDERS.get("root").expect("could not find root provider");
            let artifact = provider.transform(asml_manifest).expect("unexpected error transforming root manifest");
            content.push_str(&artifact.content().unwrap());

            let service_modules: ArtifactList = ArtifactList::new();
            for (_id, service_ref) in asml_manifest.services {
                let module = hcl::service::Module::new(self.project, service_ref);
                content.push_str(&module.cast().unwrap());
                service_modules.push(Box::new(module));
            }

            self.services = Some(service_modules);
            self.hcl = Some(content);
            Ok(content)
        }
    }
}

pub mod service {
    use crate::projectfs::Project;
    use crate::providers::*;
    use crate::materials::{hcl, toml, models, Artifact, ArtifactError, ContentType, StringMap};

    pub type ArtifactList = Vec<Box<hcl::function::Module>>;

    pub struct Module {
        hcl: Option<String>,
        pub(in super) project: Project,
        pub(in super) service_ref: toml::asml::ServiceRef,
        pub functions: Option<ArtifactList>,
        pub iomods: Option<StringMap<models::Dependency>>,
    }

    impl Module {
        pub fn new(project: Project, service_ref: toml::asml::ServiceRef) -> Self {
            Module { hcl: None, functions: None, iomods: None, project, service_ref }
        }

        pub fn name(&self) -> String {
            self.service_ref.name
        }
    }

    impl Artifact for Module {
        fn content_type(&self) -> ContentType {
            ContentType::HCL("HCL")
        }

        fn content(&self) -> Option<String> {
            self.hcl
        }

        fn cast(&mut self) -> Result<String, ArtifactError> {
            let service_name = self.service_ref.name;
            let service_manifest = toml::service::Manifest::read(&*self.project.service_dir(service_name).dir()).unwrap();
            let mut content = format!("# Begin service {}\r\n", service_name);

            let service = service_manifest.service();
            let functions = service_manifest.functions();

            let provider_name = service.provider.unwrap_or(String::from("aws-lambda"));
            let service_provider = SERVICE_PROVIDERS.get(&provider_name).expect("could not find provider by name");

            let service_artifact = service_provider.transform(service).expect("unexpected error transforming service");
            content.push_str(&service_artifact.content().unwrap());

            let function_modules: ArtifactList = ArtifactList::new();
            for (_id, function) in functions {
                let module = hcl::function::Module::new(*self, function);
                content.push_str(&module.cast().unwrap());
                function_modules.push(Box::new(module));
            }

            self.hcl = Some(content);
            self.functions = Some(function_modules);
            Ok(content)
        }
    }
}

pub mod function {
    use crate::providers::*;
    use crate::materials::{hcl, models, Artifact, ArtifactError, ContentType};

    pub struct Module {
        hcl: Option<String>,
        parent: hcl::service::Module,
        function: models::Function,
    }

    impl Module {
        pub fn new(parent: hcl::service::Module, function: models::Function) -> Self {
            Self { hcl: None, parent, function }
        }

        pub fn name(&self) -> String {
            self.function.name
        }
    }

    impl Artifact for Module {
        fn content_type(&self) -> ContentType {
            ContentType::HCL("HCL")
        }

        fn content(&self) -> Option<String> {
            self.hcl
        }

        fn cast(&mut self) -> Result<String, ArtifactError> {
            let provider_name = self.function.provider.unwrap_or(String::from("aws-lambda"));
            let function_provider = FUNCTION_PROVIDERS.get(&provider_name).expect("could not find provider by name");

            let function_artifact = function_provider.transform(self.function).expect("unexpected error transforming function");
            let content = function_artifact.cast().unwrap();
            self.hcl = Some(content);
            Ok(content)
        }
    }
}
